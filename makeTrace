#!/usr/bin/env zx
import fs from 'fs';

if (argv.h) {
  console.log(`Usage:
  
    makeTrace [chrono file] [options]
  where:
    chono file: Input, raw dump from Logisim timing diagram, defaults to 'chrono.txt'
    options:
      -o <name>: Output, name for the CSV file to produce.  Defaults to the same as the input file with '.csv' extension
      -r <name>: Rom image: name of program ROM image file produced by the assembler.
      -h: help: this file
`);
  process.exit(0);
}
let fileName = argv._[0] || 'chronogram';

let chronoFile;
let csvFile;
let romFile = 'program.rom';

if (path.extname(fileName)) {
  chronoFile = fileName;
  fileName = path.basename(fileName, path.extname(fileName));
  csvFile = fileName + '.csv';
} else {
  chronoFile = fileName + '.txt';
  csvFile = fileName + '.csv';
}

if (argv.o) {
  csvFile = argv.o;
}

if (argv.r) {
  romFile = argv.r;
  if (!path.extname(romFile)) romFile += '.rom';
}

var csv = fs.createWriteStream(csvFile);

const chrono = await fs.promises.open(chronoFile, 'r');

const rxSignalName = /^-(One_Bit_CPU\(\d*,\d*\)\/)?(\w+)\[?.*/gm;
const rxRom = /([0-9a-f]+):([0-9a-f ]+)#?(.*)$/gim;

const trace = {};
let currentSignal = null;
for await (const line of chrono.readLines({ encoding: 'utf8' })) {
  if (line.startsWith('-')) {
    const signal = line.replace(rxSignalName, '$2');
    currentSignal = trace[signal];

    if (!currentSignal) {
      currentSignal = trace[signal] = {};
    }
  } else {
    const [time, val] = line.substring(1).split(',');
    if (!currentSignal[time]) {
      currentSignal[time] = parseInt(val.replaceAll(' ', ''), 2).toString(16);
    }
  }
}
chrono.close();
const table = [];
for (const [signal, values] of Object.entries(trace)) {
  for (const [time, val] of Object.entries(values)) {
    table.push([signal, Math.round(time / 10), val]);
  }
}
table.sort((a, b) => (a[1] - b[1] ? a[1] - b[1] : a[0] - b[0]));

const names = table
  .map(([name]) => name)
  .filter((name, index, self) => index === self.findIndex((n) => name === n));
csv.write(`time, ${names.join(',')}`);

const rom = {};
if (names.includes('InstructionAddress')) {
  const r = await fs.promises.readFile(romFile, 'utf8');

  for (const match of r.matchAll(rxRom)) {
    rom[parseInt(match[1], 16)] = [match[2].trim(), match[3].trim()];
  }
}

let lastTime = null;
let address = null;
const out = { time: '' };
names.forEach((n) => {
  out[n] = '';
});

table.forEach(([name, time, val]) => {
  if (time !== lastTime && out['MasterClock'] === '1') {
    csv.write(
      `\n${Object.values(out).join(',')},${
        address in rom ? rom[address]?.join(',') : ''
      }`
    );
    address = null;
    lastTime = time;
    out.time = time;
  }
  if (name === 'InstructionAddress') {
    address = parseInt(val, 16);
  }
  out[name] = val;
});
csv.write(
  `\n${Object.values(out).join(',')},${address in rom ? rom[address]?.join(',') : ''}`
);
