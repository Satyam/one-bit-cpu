#!/usr/bin/env zx

const inFile = argv._[0] || 'program';

const keywords = {
  and: {
    bits: '000',
    argLen: 5,
  },
  or: {
    bits: '001',
    argLen: 5,
  },
  load: {
    bits: '010',
    argLen: 5,
  },
  save: {
    bits: '011',
    argLen: 5,
  },
  not: {
    bits: '10000000',
  },
  zero: {
    bits: '10001000',
  },
  one: {
    bits: '10001001',
  },
  ret: {
    bits: '10010000',
  },
  out: {
    bits: '10100000',
  },
  outinc: {
    bits: '10101000',
  },
  outdec: {
    bits: '10101001',
  },
  in: {
    bits: '10110000',
  },
  ininc: {
    bits: '10111000',
  },
  incdec: {
    bits: '10111001',
  },
  infrom: {
    bits: '11000',
    argLen: 3,
    extra: true,
  },
  outto: {
    bits: '11001',
    argLen: 3,
    extra: true,
  },
  call: {
    bits: '1100',
    argLen: 4,
    extra: true,
  },
  jt: {
    bits: '1110',
    argLen: 4,
    extra: true,
  },
  jmp: {
    bits: '1110',
    argLen: 4,
    extra: true,
  },
};

const labels = {};
let address = 0;
const ROM = [];

const rxComment = /^\s*#/;
const rxAnySpaces = /\s+/;
const rxLabel = /^[a-zA-Z]\w*$/;
let rxNumbers = {
  2: /^0b([01]+)$/,
  8: /^0o([0-7]+)$/,
  16: /^0x([0-9a-fA-F]+)$/,
  10: /^(\d+)$/,
};

const asmFile = await fs.readFile(`${inFile}.asm`, 'utf8');
const asm = asmFile.split('\n');

for (let lineNum = 0; lineNum < asm.length; lineNum++) {
  const line = asm[lineNum];

  let argValue = 0;

  if (rxComment.test(line)) continue;
  if (!line.trim()) continue;
  try {
    const [label, name, arg, comment] = line.toLowerCase().split(rxAnySpaces);
    validateLine(label, name, arg, comment);
    if (label) {
      if (labels[label]) {
        labels[label] = address;
      } else {
        labels[label] = { value: address };
      }
    }
    const instConfig = keywords[name];
    if (instConfig.argLen) {
      argValue = readArg(arg, lineNum, instConfig);
    }
    generateCode(instConfig, argValue);
  } catch (err) {
    console.error(chalk.red(`[${lineNum}]: ${err} in:\n      ${line}`));
  }
}
ROM.forEach((num) => console.log(num.toString(2).padStart(8, '0')));
console.table(labels);

function validateLine(label, name, arg, comment) {
  if (comment && !rxComment.test(comment))
    throw new Error(`Extraneous text at end of instruction "${comment}"`);
  if (!name) throw new Error('Mising instruction');
  const instConfig = keywords[name];
  if (!instConfig) throw new Error(`Unkown instruction "${name}"`);
  if (label) {
    if (!rxLabel.test(label)) throw new Error(`Invalid label ${label}`);
    if (labels[label]?.value)
      throw new Error(`Duplicate definition of label ${label}`);
  }
  if (instConfig.argLen) {
    if (!arg) throw new Error(`Missing argument for "${name}"`);
  } else {
    if (arg) throw new Error(`Unexpected argument "${arg}"`);
  }
}

function readArg(arg, lineNum, instConfig) {
  let value;
  if (
    Object.entries(rxNumbers).some(([base, rx]) => {
      const m = rx.exec(arg);
      if (m) {
        value = parseInt(m[1], base);
        return true;
      }
    })
  ) {
    const numBits = instConfig.argLen + (instConfig.extra ? 8 : 0);
    if (value >= 1 << numBits) {
      throw new Error(
        `Numeric argument "${arg}" (${value}) larger than ${(1 << numBits) - 1}`
      );
    }
    return value;
  }
  if (rxLabel.test(arg)) {
    const lblConfig = labels[arg];
    if (lblConfig) {
      if (lblConfig.value) return lblConfig.value;
      else {
        lblConfig.pending.push({ lineNum, address, instConfig });
      }
    } else {
      labels[arg] = {
        pending: [
          {
            lineNum,
            address,
            instConfig,
          },
        ],
      };
    }
  }

  throw new Error(`Invalid argument value ${arg}`);
}

function generateCode(config, argValue) {
  let code = parseInt(config.bits, 2);
  if (config.argLen) {
    code <<= config.argLen;
    code += config.extra ? argValue >>> 8 : argValue;
    ROM.push(code);
    address++;
    if (config.extra) {
      ROM.push(argValue % 256);
      address++;
    }
  } else {
    ROM.push(code);
    address++;
  }
}
