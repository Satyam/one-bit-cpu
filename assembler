#!/usr/bin/env zx

const fileName = argv._[0] || 'program';

let inFile;
let outFile;
let hasError = false;

if (path.extname(fileName)) {
  inFile = fileName;
  outFile = path.basename(fileName) + '.rom';
} else {
  inFile = fileName + '.asm';
  outFile = fileName + '.rom';
}

if (argv.o) {
  outFile = argv.o;
  if (!path.extname) outFile = outFile + '.rom';
}

const keywords = {
  and: {
    bitCode: '000',
    argLen: 5,
  },
  or: {
    bitCode: '001',
    argLen: 5,
  },
  load: {
    bitCode: '010',
    argLen: 5,
  },
  save: {
    bitCode: '011',
    argLen: 5,
  },
  not: {
    bitCode: '10000000',
  },
  zero: {
    bitCode: '10001000',
  },
  one: {
    bitCode: '10001100',
  },
  ret: {
    bitCode: '10010000',
  },
  out: {
    bitCode: '10100000',
  },
  outinc: {
    bitCode: '10101000',
  },
  outdec: {
    bitCode: '10101100',
  },
  in: {
    bitCode: '10110000',
  },
  ininc: {
    bitCode: '10111000',
  },
  incdec: {
    bitCode: '10111100',
  },
  infrom: {
    bitCode: '11000',
    argLen: 3,
    extra: true,
  },
  outto: {
    bitCode: '11001',
    argLen: 3,
    extra: true,
  },
  call: {
    bitCode: '1101',
    argLen: 4,
    extra: true,
  },
  jmpt: {
    bitCode: '1110',
    argLen: 4,
    extra: true,
  },
  jmp: {
    bitCode: '1111',
    argLen: 4,
    extra: true,
  },
};

// address values for the labels will be collected here
const labelValues = {};

// output ROM image
const romImage = ['v3.0 hex words plain'];

// Various regular expressions, mostly for validation
const rxComment = /^\s*#/;
const rxAnySpaces = /\s+/;
const rxLabel = /^[a-zA-Z]\w*$/;

// used to detect base used for number constants
const rxNumerBases = {
  2: /^0b([01]+)$/,
  8: /^0o([0-7]+)$/,
  16: /^0x([0-9a-fA-F]+)$/,
  10: /^(\d+)$/,
};

// read the assemblre code
const asmFile = await fs.readFile(inFile, 'utf8');
const asm = asmFile.split('\n');

// First pass,
// * validate lines
// * collect addresses associated with labels
let address = 0;
for (let lineNum = 0; lineNum < asm.length; lineNum++) {
  const line = asm[lineNum];

  // Skip comments or empty lines
  if (rxComment.test(line)) continue;
  if (!line.trim()) continue;

  try {
    // parse line
    const [label, name, arg, comment] = parseLine(line);
    // validate
    validateLine(label, name, arg, comment);
    // if it has a label store the instruction address
    if (label) labelValues[label] = address;
    // update the address
    address += keywords[name].extra ? 2 : 1;
  } catch (err) {
    console.error(chalk.red(`[${lineNum + 1}]: ${err} in:\n      ${line}`));
    hasError = true;
  }
}

if (hasError) {
  console.error('Assembly canceled due to errors');
  process.exit(1);
}
// Second pass
// * generate code
for (let lineNum = 0; lineNum < asm.length; lineNum++) {
  const line = asm[lineNum];

  // skip comments and empty lines
  if (rxComment.test(line)) continue;
  if (!line.trim()) continue;

  try {
    // _label is not used in this step but it has to have a placeholder
    const [_label, name, arg] = parseLine(line);

    const config = keywords[name];

    // Convert the argument into a numeric value
    const argValue = readArg(arg, config);

    // get the actual bitcode
    let code = parseInt(config.bitCode, 2);

    // merge argument or part of it if it is a two byte instruction
    if (config.argLen) {
      code <<= config.argLen;
      code += config.extra ? argValue >>> 8 : argValue;
    }

    romImage.push(
      `${toHex(code)} ${config.extra ? toHex(argValue % 256) : ''} # [${
        lineNum + 1
      }]: ${line}`
    );
  } catch (err) {
    console.error(chalk.red(`[${lineNum + 1}]: ${err} in:\n      ${line}`));
    hasError = true;
  }
}

if (!hasError) {
  fs.writeFile(outFile, romImage.join('\n'));
  console.log(`ROM image created in "${outFile}"`);
}

function toHex(num) {
  return num.toString(16).padStart(2, '0');
}

function parseLine(line) {
  // split line in before and after the first comment
  const [before, ...after] = line.split('#');
  // rebuild the comments if there are any
  const comments = after.length ? '#' + after.join('#') : '';
  // split the instruction part
  const [label, name, arg] = before.toLowerCase().split(rxAnySpaces);
  // return parts.
  return [label, name, arg, comments];
}

// validation
// the error messages explain what it is checking
function validateLine(label, name, arg, comment) {
  if (comment && !rxComment.test(comment))
    throw new Error(`Extraneous text at end of instruction "${comment}"`);
  if (!name) throw new Error('Mising instruction');
  const config = keywords[name];
  if (!config) throw new Error(`Unknown instruction "${name}"`);
  if (label) {
    if (!rxLabel.test(label)) throw new Error(`Invalid label ${label}`);
    if (labelValues[label])
      throw new Error(`Duplicate definition of label ${label}`);
  }
  if (config.argLen) {
    if (!arg) throw new Error(`Missing argument for "${name}"`);
  } else {
    if (arg) throw new Error(`Unexpected argument "${arg}"`);
  }
}

function readArg(arg, config) {
  if (!config.argLen) return 0;
  let value;

  // loop over the regular expressions to check for number base prefixes
  // and parse it accordingly if match
  if (
    Object.entries(rxNumerBases).some(([base, rx]) => {
      const m = rx.exec(arg);
      if (m) {
        value = parseInt(m[1], base);
        return true;
      }
    })
  ) {
    // a match was found, now check for valid argument range
    const numBits = config.argLen + (config.extra ? 8 : 0);
    if (value >= 1 << numBits) {
      throw new Error(
        `Numeric argument "${arg}" (${value}) larger than ${(1 << numBits) - 1}`
      );
    }
    return value;
  }

  // It was not a number, perhaps it is a label?
  if (rxLabel.test(arg)) {
    value = labelValues[arg];
    if (Number.isInteger(value)) return value;
  }

  // wasn't a known label
  throw new Error(`Invalid argument value ${arg}`);
}
